{"version":3,"file":"pixi-tilemap.mjs","sources":["../src/settings.ts","../src/TilemapGeometry.ts","../src/TilemapPipe.ts","../src/TileTextureArray.ts","../src/gl_tilemap.ts","../src/gpu_tilemap.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/index.ts"],"sourcesContent":["import { SCALE_MODE } from 'pixi.js';\n\n/**\n * These are additional @pixi/tilemap options.\n *\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\n * is undefined.\n */\nexport const settings = {\n    /** The default number of textures per tilemap in a tilemap composite. */\n    TEXTURES_PER_TILEMAP: 16,\n\n    /** The scaling mode of the combined texture tiling. */\n    TEXTILE_SCALE_MODE: 'linear' as SCALE_MODE,\n\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\n    use32bitIndex: false,\n};\n\n// @deprecated\nexport const Constant = settings;\n","import { Buffer, BufferUsage, Geometry } from 'pixi.js';\n\n// For some reason, ESLint goes mad with indentation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nexport class TilemapGeometry extends Geometry\n{\n    static vertSize = 13;\n    static vertPerQuad = 4;\n    static stride = this.vertSize * 4;\n    lastTimeAccess = 0;\n\n    vertSize = TilemapGeometry.vertSize;\n    vertPerQuad = TilemapGeometry.vertPerQuad;\n    stride = TilemapGeometry.stride;\n\n    constructor(indexBuffer: Buffer)\n    {\n        const buf = new Buffer({\n            data: new Float32Array(2),\n            label: 'tilemap-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const stride = TilemapGeometry.stride;\n\n        // TODO: why location is like that in webgl? ascending?\n\n\t    super({\n            indexBuffer,\n            attributes: {\n                aVertexPosition: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                    // location: 6,\n                },\n                aTextureCoord: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                    // location: 4,\n                },\n                aFrame: {\n                    buffer: buf,\n                    format: 'float32x4',\n                    stride,\n                    offset: 4 * 4,\n                    // location: 3,\n                },\n                aAnim: {\n                    buffer: buf,\n                    format: 'float32x2',\n                    stride,\n                    offset: 8 * 4,\n                    // location: 1,\n                },\n                aTextureId: {\n                    buffer: buf,\n                    format: 'sint32',\n                    stride,\n                    offset: 10 * 4,\n                    // location: 5\n                },\n                aAnimDivisor: {\n                    buffer: buf,\n                    format: 'float32',\n                    stride,\n                    offset: 11 * 4,\n                    // location: 2\n                },\n                aAlpha: {\n                    buffer: buf,\n                    format: 'float32',\n                    stride,\n                    offset: 12 * 4,\n                    // location: 0\n                }\n            },\n        });\n\n        this.buf = buf;\n    }\n\n    buf: Buffer;\n}\n","import {\n    Buffer,\n    BufferUsage, ExtensionType, GlobalUniformGroup,\n    IndexBufferArray, Instruction, InstructionPipe, InstructionSet, Matrix, NOOP, Renderer,\n    RenderPipe, UniformGroup\n} from 'pixi.js';\nimport { CompositeTilemap } from './CompositeTilemap';\nimport { settings } from './settings';\nimport { TilemapGeometry } from './TilemapGeometry';\n\nimport type { Tilemap } from './Tilemap';\n\n// For some reason, ESLint goes mad with indentation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nexport abstract class TilemapAdaptor\n{\n    abstract init(): void;\n    abstract execute(meshPipe: TilemapPipe, mesh: Tilemap): void;\n    abstract destroy(): void;\n\n    public pipe_uniforms = new UniformGroup({\n        u_proj_trans: { value: new Matrix(), type: 'mat3x3<f32>' },\n        u_anim_frame: { value: new Float32Array(2), type: 'vec2<f32>' },\n    });\n}\n\nexport interface TilemapInstruction extends Instruction\n{\n    renderPipeId: 'tilemap';\n    tilemap: Tilemap;\n}\n\n/**\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\n */\nexport class TilemapPipe implements RenderPipe<Tilemap>, InstructionPipe<TilemapInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'tilemap',\n    } as const;\n    /** The managing renderer */\n    public readonly renderer: Renderer;\n\n    /** The tile animation frame */\n    public tileAnim = [0, 0];\n\n    private ibLen = 0;// index buffer length\n\n    /** The index buffer for the tilemaps to share. */\n    private indexBuffer: Buffer = null;\n\n    /** The shader used to render tilemaps. */\n    private shader: TilemapGeometry;\n\n    private adaptor: TilemapAdaptor;\n\n    constructor(renderer: Renderer, adaptor: TilemapAdaptor)\n    {\n        this.renderer = renderer;\n        this.adaptor = adaptor;\n\n        this.adaptor.init();\n\n\t    this.indexBuffer = new Buffer({\n            data: new Uint16Array([0, 1, 2, 0, 2, 3]),\n            label: 'index-tilemap-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n        // Remove the destroy method from the index buffer to prevent it from being destroyed.\n        // This is because the index buffer is shared between all tilemaps,\n        // and .destroy will be called when destroying a tilemap.\n        this.indexBuffer.destroy = NOOP;\n\n\t    this.checkIndexBuffer(2000);\n    }\n\n    start(): void\n    {\n\t    // sorry, nothing\n    }\n\n    /**\n\t * @internal\n\t * @ignore\n\t */\n    createVb(): TilemapGeometry\n    {\n\t    const geom = new TilemapGeometry(this.indexBuffer);\n\n        geom.lastTimeAccess = Date.now();\n\n\t    return geom;\n    }\n\n    /** @return The {@link TilemapGeometry} shader that this rendering pipeline is using. */\n    getShader(): TilemapGeometry { return this.shader; }\n\n    destroy(): void\n    {\n\t    // this.rectShader.destroy();\n\t    this.shader = null;\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    public checkIndexBuffer(size: number): void\n    {\n\t    const totalIndices = size * 6;\n\n\t    if (totalIndices <= this.ibLen)\n\t    {\n\t        return;\n\t    }\n\n\t    let len = totalIndices;\n\n\t    while (len < totalIndices)\n\t    {\n\t        len <<= 1;\n\t    }\n\n\t    this.ibLen = totalIndices;\n\t    this.indexBuffer.data = createIndicesForQuads(size,\n\t        settings.use32bitIndex ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices));\n    }\n\n    destroyRenderable(_renderable: Tilemap): void\n    {\n        _renderable.vb.destroy(true);\n        _renderable.vb = null;\n    }\n\n    addRenderable(tilemap: Tilemap, instructionSet: InstructionSet | undefined): void\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        tilemap.updateBuffer(this);\n        tilemap.checkValid();\n        tilemap.getTileset().update();\n\n        if (tilemap.is_valid)\n        {\n            batcher.break(instructionSet);\n            instructionSet.add(tilemap._instruction);\n        }\n    }\n\n    updateRenderable(tilemap: Tilemap, _instructionSet?: InstructionSet | undefined): void\n    {\n        tilemap.updateBuffer(this);\n        tilemap.getTileset().update();\n    }\n\n    validateRenderable(renderable: Tilemap): boolean\n    {\n        return renderable.checkValid();\n    }\n\n    public execute({ tilemap }: TilemapInstruction)\n    {\n        if (!tilemap.isRenderable) return;\n\n        tilemap.state.blendMode = tilemap.groupBlendMode;\n\n        const { pipe_uniforms } = this.adaptor;\n\n        const u_proj_trans = pipe_uniforms.uniforms.u_proj_trans;\n        const u_global = ((this.renderer.globalUniforms as any)._activeUniforms.at(-1) as GlobalUniformGroup).uniforms;\n        let anim_frame = this.tileAnim;\n        const { u_anim_frame } = pipe_uniforms.uniforms;\n\n        u_global.uProjectionMatrix.copyTo(u_proj_trans).append(u_global.uWorldTransformMatrix)\n            .append(tilemap.worldTransform);\n        if (tilemap.compositeParent)\n        {\n            anim_frame = (tilemap.parent as CompositeTilemap).tileAnim || anim_frame;\n        }\n        u_anim_frame[0] = anim_frame[0];\n        u_anim_frame[1] = anim_frame[1];\n\n        pipe_uniforms.update();\n\n        this.adaptor.execute(this, tilemap);\n    }\n}\n\nfunction createIndicesForQuads(\n    size: number,\n    outBuffer: IndexBufferArray\n): IndexBufferArray\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import { BindGroup, Buffer, BufferUsage, Texture, TextureSource, UniformGroup } from 'pixi.js';\n\nexport class TileTextureArray\n{\n    max_textures: number;\n    constructor(max_textures: number)\n    {\n        this.max_textures = max_textures;\n        this.tex_sizes = new Float32Array((this.max_textures * 4) + 4);\n        this.tex_buf = new Buffer({\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n        });\n    }\n\n    arr: TextureSource[] = [];\n    count = 0;\n    dirty = false;\n    dirty_gpu = false;\n    bind_group: BindGroup = null;\n    bind_group_resources: any = {};\n    tex_sizes: Float32Array = null;\n    null_color: Float32Array = new Float32Array([0, 0, 0, 0.5]);\n    tex_buf: Buffer = null;\n\n    get length()\n    {\n        return this.count;\n    }\n\n    push(tex: TextureSource)\n    {\n        this.arr[this.count++] = tex;\n        this.dirty = true;\n    }\n\n    at(ind: number)\n    {\n        return this.arr[ind];\n    }\n\n    update()\n    {\n        if (!this.dirty)\n        {\n            return;\n        }\n\n        this.dirty = false;\n        this.dirty_gpu = true;\n\n        const { tex_sizes, arr, count, max_textures, null_color } = this;\n\n        for (let i = 0; i < count; i++)\n        {\n            const tex = arr[i];\n\n            if (tex)\n            {\n                tex_sizes[(i * 4)] = tex.pixelWidth;\n                tex_sizes[(i * 4) + 1] = tex.pixelHeight;\n                tex_sizes[(i * 4) + 2] = 1.0 / tex.pixelWidth;\n                tex_sizes[(i * 4) + 3] = 1.0 / tex.pixelHeight;\n            }\n        }\n\n        tex_sizes[max_textures * 4] = null_color[0];\n        tex_sizes[(max_textures * 4) + 1] = null_color[1];\n        tex_sizes[(max_textures * 4) + 2] = null_color[2];\n        tex_sizes[(max_textures * 4) + 3] = null_color[3];\n    }\n\n    markDirty()\n    {\n        this.dirty = true;\n    }\n\n    getBindGroup()\n    {\n        this.update();\n        if (!this.dirty_gpu)\n        {\n            return this.bind_group;\n        }\n\n        const { bind_group_resources, max_textures, arr, count } = this;\n\n        let bindIndex = 0;\n\n        bind_group_resources[bindIndex++] = new UniformGroup({\n            u_texture_size: {\n                value: this.tex_sizes,\n                type: 'vec4<f32>',\n                size: max_textures\n            },\n            u_null_color: {\n                value: this.null_color,\n                type: 'vec4<f32>'\n            },\n        });\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            const texture = (i < count ? arr[i] : null) || Texture.EMPTY.source;\n\n            bind_group_resources[bindIndex++] = texture.source;\n            bind_group_resources[bindIndex++] = texture.style;\n        }\n\n        if (!this.bind_group)\n        {\n            this.bind_group = new BindGroup(bind_group_resources);\n        }\n\n        return this.bind_group;\n    }\n\n    static generate_gpu_textures(max_textures: number): string\n    {\n        const src: string[] = [];\n\n        src.push(`struct TextureArrayFields {`);\n        src.push(`    u_texture_size: array<vec4f, ${max_textures}>,`);\n        src.push(`    u_null_color: vec4f`);\n        src.push(`}`);\n        src.push(`@group(1) @binding(0) var<uniform> taf: TextureArrayFields;`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`@group(1) @binding(${(i * 2) + 1}) var u_texture_${i}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${(i * 2) + 2}) var u_sampler_${i}: sampler;`);\n        }\n\n        src.push('fn sampleMultiTexture(texture_id: i32, uv: vec2f, dx: vec2f, dy: vec2f) -> vec4f {');\n        src.push(`switch texture_id {`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`  case ${i}: { return textureSampleGrad(u_texture_${i}, u_sampler_${i}, uv, dx, dy); }`);\n        }\n        src.push(`  default: { return taf.u_null_color; }`);\n        src.push('} }');\n\n        return src.join('\\n');\n    }\n\n    static generate_gl_textures(max_textures: number): string\n    {\n        const src: string[] = [];\n\n        src.push(`uniform vec4 u_texture_size[${max_textures + 1}];`);\n        src.push(`uniform sampler2D u_textures[${max_textures}];`);\n        src.push(`uniform vec4 u_null_color;`);\n\n        src.push('vec4 sampleMultiTexture(float texture_id, vec2 uv) {');\n        src.push(`if(texture_id < -0.5) return u_texture_size[${max_textures}];`);\n        for (let i = 0; i < max_textures; i++)\n        {\n            src.push(`if(texture_id < ${i}.5) return texture(u_textures[${i}], uv * u_texture_size[${i}].zw);`);\n        }\n        src.push(`return u_texture_size[${max_textures}];`);\n        src.push('}');\n\n        return src.join('\\n');\n    }\n\n    static gl_gen_resources(max_textures: number): any\n    {\n        const sampleValues: Array<number> = [];\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            sampleValues[i] = i;\n        }\n\n        const samplerSize: Array<number> = [];\n\n        for (let i = 0; i < max_textures; i++)\n        {\n            // These are overwritten by TilemapRenderer when textures actually bound.\n            samplerSize.push(2048);\n            samplerSize.push(2048);\n            samplerSize.push(1.0 / 2048);\n            samplerSize.push(1.0 / 2048);\n        }\n\n        return {\n            u_textures: {\n                value: sampleValues,\n                type: 'i32',\n                size: max_textures\n            },\n            u_texture_size: {\n                value: samplerSize,\n                type: 'vec4<f32>',\n                size: max_textures\n            }\n        };\n    }\n}\n","import { ExtensionType, GlProgram, Shader, UniformGroup, WebGLRenderer } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nconst gl_tilemap_vertex = `\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\nin vec4 aFrame;\nin vec2 aAnim;\nin float aAnimDivisor;\nin float aTextureId;\nin float aAlpha;\n\nuniform mat3 u_proj_trans;\nuniform vec2 u_anim_frame;\n\nout vec2 vTextureCoord;\nout float vTextureId;\nout vec4 vFrame;\nout float vAlpha;\n\nvoid main(void)\n{\n  gl_Position = vec4((u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n  vec2 animFrameOffset = aAnim - animCount * 2048.0;\n  vec2 currentFrame = floor(u_anim_frame / aAnimDivisor);\n  vec2 loop_num = floor((currentFrame + 0.5) / animCount);\n  vec2 animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n\n  vTextureCoord = aTextureCoord + animOffset;\n  vFrame = aFrame + vec4(animOffset, animOffset);\n  vTextureId = aTextureId;\n  vAlpha = aAlpha;\n}\n`;\n\nconst gl_tilemap_fragment = `\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nin vec2 vTextureCoord;\nin vec4 vFrame;\nin float vTextureId;\nin float vAlpha;\n\n//include_textures\n\nvoid main(void)\n{\n  float textureId = floor(vTextureId + 0.5);\n  vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  vec4 color = sampleMultiTexture(textureId, textureCoord);\n  finalColor = color * vAlpha;\n}\n`;\n\nexport class GlTilemapAdaptor extends TilemapAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'tilemap',\n    } as const;\n\n    _shader: Shader = null;\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\n\n    destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\n    {\n        const renderer = pipe.renderer as WebGLRenderer;\n        const shader = this._shader;\n        const tileset = tilemap.getTileset();\n\n        const tu = shader.resources.texture_uniforms;\n\n        if (tu.uniforms.u_texture_size !== tileset.tex_sizes)\n        {\n            tu.uniforms.u_texture_size = tileset.tex_sizes;\n            tu.update();\n        }\n\n        for (let i = 0; i < tileset.length; i++)\n        {\n            renderer.texture.bind(tileset.arr[i], i);\n        }\n\n        renderer.encoder.draw({\n            geometry: tilemap.vb,\n            shader,\n            state: tilemap.state,\n            size: tilemap.rects_count * 6\n        });\n\n        // TODO: support several tilemaps here, without re-setting extra uniforms\n    }\n\n    init(): void\n    {\n        this._shader = new Shader({\n            glProgram: GlProgram.from({\n                vertex: gl_tilemap_vertex,\n                fragment: gl_tilemap_fragment.replace('//include_textures',\n                    TileTextureArray.generate_gl_textures(this.max_textures))\n            }),\n            resources: {\n                texture_uniforms: new UniformGroup(TileTextureArray.gl_gen_resources(this.max_textures), { isStatic: true }),\n                pipe_uniforms: this.pipe_uniforms.uniformStructures,\n            },\n        });\n    }\n}\n","import { BindGroup, ExtensionType, GpuProgram, Shader } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nconst gpu_tilemap_vertex = `\nstruct GlobalUniforms {\n  uProjectionMatrix:mat3x3f,\n  uWorldTransformMatrix:mat3x3f,\n  uWorldColorAlpha: vec4f,\n  uResolution: vec2f,\n}\n\nstruct TilemapUniforms {\n  u_proj_trans:mat3x3f,\n  u_anim_frame:vec2f\n}\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\n\nstruct VSOutput {\n  @builtin(position) vPosition: vec4f,\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32\n};\n\n@vertex\nfn mainVert(\n   @location(6) aVertexPosition: vec2f,\n   @location(4) aTextureCoord: vec2f,\n   @location(3) aFrame: vec4f,\n   @location(1) aAnim: vec2f,\n   @location(2) aAnimDivisor: f32,\n   @location(5) aTextureId: i32,\n   @location(0) aAlpha: f32,\n ) -> VSOutput {\n\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  var animCount = floor((aAnim + 0.5) / 2048.0);\n  var animFrameOffset = aAnim - animCount * 2048.0;\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\n  var loop_num = floor((currentFrame + 0.5) / animCount);\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n  var vTextureCoord = aTextureCoord + animOffset;\n  var vFrame = aFrame + vec4(animOffset, animOffset);\n\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aAlpha);\n};\n`;\n\nconst gpu_tilemap_fragment = `\n//include_textures\n\n@fragment\nfn mainFrag(\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32,\n  ) -> @location(0) vec4f {\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\n  return color * vAlpha;\n};\n`;\n\nexport class GpuTilemapAdaptor extends TilemapAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'tilemap',\n    } as const;\n\n    _shader: Shader = null;\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\n    bind_group: BindGroup = null;\n\n    destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\n    {\n        const renderer = pipe.renderer;\n        const shader = this._shader;\n        // GPU..\n\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n        shader.groups[1] = tilemap.getTileset().getBindGroup();\n        shader.groups[2] = this.bind_group;\n\n        renderer.encoder.draw({\n            geometry: tilemap.vb,\n            shader,\n            state: tilemap.state,\n            size: tilemap.rects_count * 6\n        });\n        // TODO: does it need groups?\n    }\n\n    init(): void\n    {\n        this._shader = new Shader({\n            gpuProgram: GpuProgram.from({\n                vertex: { source: gpu_tilemap_vertex, entryPoint: 'mainVert' },\n                fragment: {\n                    source: gpu_tilemap_fragment\n                        .replace('//include_textures', TileTextureArray.generate_gpu_textures(this.max_textures))\n                },\n            })\n        });\n\n        this.bind_group = new BindGroup({\n            ut: this.pipe_uniforms\n        });\n    }\n}\n","/* eslint-disable no-unused-vars */\nimport { Bounds, groupD8, State, Texture, TextureSource, ViewContainer } from 'pixi.js';\nimport { settings } from './settings';\nimport { TilemapInstruction, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nimport type { DestroyOptions } from 'pixi.js';\nimport type { TilemapGeometry } from './TilemapGeometry';\n\nenum POINT_STRUCT\n    {\n    U,\n    V,\n    X,\n    Y,\n    TILE_WIDTH,\n    TILE_HEIGHT,\n    ROTATE,\n    ANIM_X,\n    ANIM_Y,\n    TEXTURE_INDEX,\n    ANIM_COUNT_X,\n    ANIM_COUNT_Y,\n    ANIM_DIVISOR,\n    ALPHA,\n}\n\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\n\n/**\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\n *\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\n *\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\n * instances.\n *\n * @example\n * import { Tilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Add the spritesheet into your loader!\n * Loader.shared.add('atlas', 'assets/atlas.json');\n *\n * // Make the tilemap once the tileset assets are available.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      // The base-texture is shared between all the tile textures.\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\n *          .tile('grass.png', 0, 0)\n *          .tile('grass.png', 100, 100)\n *          .tile('brick_wall.png', 0, 100);\n * });\n */\nexport class Tilemap extends ViewContainer\n{\n    // TODO: make default color work\n    /**\n     * Currently doesnt work.\n     */\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    state = State.for2d();\n\n    is_valid = false;\n\n    public readonly renderPipeId = 'tilemap';\n    public readonly canBundle = true;\n\n    _instruction = {\n        renderPipeId: 'tilemap',\n        tilemap: this as Tilemap\n    } as TilemapInstruction;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    checkValid()\n    {\n        const v = this.tileset.count > 0 && this.pointsBuf.length > 0;\n        const res = this.is_valid !== v;\n\n        this.is_valid = v;\n\n        return res !== v;\n    }\n\n    /**\n     * The tile animation frame.\n     *\n     * @see CompositeTilemap.tileAnim\n     */\n    public tileAnim: [number, number] = null;\n\n    /**\n     * This is the last uploaded size of the tilemap geometry.\n     * @ignore\n     */\n    rects_count = 0;\n\n    /** @ignore */\n    compositeParent = false;\n\n    /**\n     * The list of base-textures being used in the tilemap.\n     *\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\n     * should be added after tiles have been added into the map.\n     */\n    protected tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n    /**\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\n     */\n    protected readonly tilemapBounds = new Bounds();\n\n    /** Flags whether any animated tile was added. */\n    protected hasAnimatedTile = false;\n\n    /** The interleaved geometry of the tilemap. */\n    private pointsBuf: Array<number> = [];\n\n    protected updateBounds(): void\n    {\n        const bounds = this.tilemapBounds;\n\n        this._bounds.minX = bounds.minX;\n        this._bounds.maxX = bounds.maxX;\n        this._bounds.minY = bounds.minY;\n        this._bounds.maxY = bounds.maxY;\n    }\n\n    public batched: boolean;\n\n    /**\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\n     *      base-textures in this array must not be duplicated.\n     */\n    constructor(tileset: TextureSource | Array<TextureSource>)\n    {\n        super({});\n        this.setTileset(tileset);\n    }\n\n    /**\n     * @returns The tileset of this tilemap.\n     */\n    getTileset(): TileTextureArray\n    {\n        return this.tileset;\n    }\n\n    /**\n     * Define the tileset used by the tilemap.\n     *\n     * @param textureOrArray - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\n     *  be wrapped into an array. This should not contain any duplicates.\n     */\n    setTileset(textureOrArray: TileTextureArray | TextureSource | Array<TextureSource> = []): this\n    {\n        let ts = this.tileset;\n\n        if (textureOrArray instanceof TileTextureArray)\n        {\n            this.tileset = textureOrArray;\n            this.didViewUpdate = true;\n        }\n        else if (textureOrArray instanceof TextureSource)\n        {\n            if (ts.count === 1 && ts.arr[0] === textureOrArray)\n            {\n                return this;\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n            ts.push(textureOrArray);\n            this.didViewUpdate = true;\n        }\n        else\n        {\n            if (textureOrArray.length === ts.count)\n            {\n                let flag = true;\n\n                for (let i = 0; i < textureOrArray.length; i++)\n                {\n                    if (textureOrArray[i]?.source !== ts.arr[i])\n                    {\n                        flag = false;\n                        break;\n                    }\n                }\n\n                if (flag)\n                {\n                    return this;\n                }\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n            for (let i = 0; i < textureOrArray.length; i++)\n            {\n                ts.push(textureOrArray[i]?.source);\n            }\n            this.didViewUpdate = true;\n        }\n\n        return this;\n    }\n\n    /**  Clears all the tiles added into this tilemap. */\n    clear(): this\n    {\n        this.pointsBuf.length = 0;\n        this.rects_count = 0;\n        this.tilemapBounds.clear();\n        this.hasAnimatedTile = false;\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given texture at (x, y).\n     *\n     * @param tileTexture - The tiling texture to render.\n     * @param x - The local x-coordinate of the tile's position.\n     * @param y - The local y-coordinate of the tile's position.\n     * @param options - Additional tile options.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n     *      animation frame textures in the base-texture.\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n     *      animation frames textures in the base-texture.\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n     *      per row.\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n     *      per column.\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\n     * @param [options.alpha=1] - Tile alpha\n     * @return This tilemap, good for chaining.\n     */\n    tile(\n        tileTexture: number | string | Texture | TextureSource,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number,\n            animDivisor?: number,\n            alpha?: number,\n        } = {}\n    ): this\n    {\n        this.didViewUpdate = true;\n        let baseTexture: TextureSource;\n        let textureIndex = -1;\n        let was_num = false;\n\n        if (typeof tileTexture === 'number')\n        {\n            textureIndex = tileTexture;\n            was_num = true;\n            baseTexture = this.tileset.arr[textureIndex];\n        }\n        else\n        {\n            let texture: Texture | TextureSource;\n\n            if (typeof tileTexture === 'string')\n            {\n                texture = Texture.from(tileTexture);\n            }\n            else\n            {\n                texture = tileTexture;\n            }\n\n            const textureList = this.tileset;\n\n            for (let i = 0; i < textureList.count; i++)\n            {\n                if (textureList.arr[i] === texture.source)\n                {\n                    textureIndex = i;\n                    break;\n                }\n            }\n\n            if ('frame' in texture)\n            {\n                options.u = options.u ?? texture.frame.x;\n                options.v = options.v ?? texture.frame.y;\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\n            }\n\n            baseTexture = texture.source;\n        }\n\n        if (!was_num && !baseTexture)\n        {\n            console.error('The tile texture was not found in the tilemap tileset.');\n\n            return this;\n        }\n\n        const {\n            u = 0,\n            v = 0,\n            tileWidth = baseTexture.width,\n            tileHeight = baseTexture.height,\n            animX = 0,\n            animY = 0,\n            rotate = 0,\n            animCountX = 1024,\n            animCountY = 1024,\n            animDivisor = 1,\n            alpha = 1,\n        } = options;\n\n        const pb = this.pointsBuf;\n\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\n\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n        pb.push(animDivisor);\n        pb.push(alpha);\n\n        this.tilemapBounds.addFrame(x, y, x + tileWidth, y + tileHeight);\n\n        return this;\n    }\n\n    /** Changes the rotation of the last tile. */\n    tileRotate(rotate: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\n    }\n\n    /** Changes the `animX`, `animCountX` of the last tile. */\n    tileAnimX(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n    }\n\n    /** Changes the `animY`, `animCountY` of the last tile. */\n    tileAnimY(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\n    }\n\n    /** Changes the `animDivisor` value of the last tile. */\n    tileAnimDivisor(divisor: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\n    }\n\n    tileAlpha(alpha: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\n    }\n\n    private vbId = 0;\n    vb: TilemapGeometry = null;\n    private vbBuffer: ArrayBuffer = null;\n    private vbArray: Float32Array = null;\n    private vbInts: Uint32Array = null;\n\n    private destroyVb(): void\n    {\n        if (this.vb)\n        {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    updateBuffer(plugin: TilemapPipe)\n    {\n        const points = this.pointsBuf;\n        const rects_count = points.length / POINT_STRUCT_SIZE;\n        let vb = this.vb;\n\n        if (this.tileset.count === 0 || rects_count === 0 || (this.rects_count === rects_count && vb))\n        {\n            return;\n        }\n        this.rects_count = rects_count;\n\n        // lost context! recover!\n\n        if (!vb)\n        {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n        }\n\n        // if layer was changed, re-upload vertices\n        const vertices = rects_count * vb.vertPerQuad;\n\n        plugin.checkIndexBuffer(rects_count);\n\n        const vertexBuf = vb.getBuffer('aVertexPosition');\n        const vs = vb.stride * vertices;\n\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\n        {\n            // !@#$ happens, need resize\n            let bk = vb.stride;\n\n            while (bk < vs)\n            {\n                bk *= 2;\n            }\n            this.vbBuffer = new ArrayBuffer(bk);\n            this.vbArray = new Float32Array(this.vbBuffer);\n            this.vbInts = new Uint32Array(this.vbBuffer);\n        }\n\n        const arr = this.vbArray;\n        const ints = this.vbInts;\n        let sz = 0;\n        let textureId = 0;\n\n        for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\n        {\n            const eps = 0.5;\n\n            if (this.compositeParent)\n            {\n                textureId = points[i + POINT_STRUCT.TEXTURE_INDEX];\n            }\n            const x = points[i + POINT_STRUCT.X];\n            const y = points[i + POINT_STRUCT.Y];\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\n            const u = points[i + POINT_STRUCT.U];\n            const v = points[i + POINT_STRUCT.V];\n            let rotate = points[i + POINT_STRUCT.ROTATE];\n\n            const animX = points[i + POINT_STRUCT.ANIM_X];\n            const animY = points[i + POINT_STRUCT.ANIM_Y];\n            const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\n            const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\n\n            const animXEncoded = animX + (animWidth * 2048);\n            const animYEncoded = animY + (animHeight * 2048);\n            const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\n            const alpha = points[i + POINT_STRUCT.ALPHA];\n\n            let u0: number;\n            let v0: number; let u1: number;\n            let v1: number; let u2: number;\n            let v2: number; let u3: number;\n            let v3: number;\n\n            if (rotate === 0)\n            {\n                u0 = u;\n                v0 = v;\n                u1 = u + w;\n                v1 = v;\n                u2 = u + w;\n                v2 = v + h;\n                u3 = u;\n                v3 = v + h;\n            }\n            else\n            {\n                let w2 = w / 2;\n                let h2 = h / 2;\n\n                if (rotate % 4 !== 0)\n                {\n                    w2 = h / 2;\n                    h2 = w / 2;\n                }\n                const cX = u + w2;\n                const cY = v + h2;\n\n                rotate = groupD8.add(rotate, groupD8.NW);\n                u0 = cX + (w2 * groupD8.uX(rotate));\n                v0 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                u1 = cX + (w2 * groupD8.uX(rotate));\n                v1 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u2 = cX + (w2 * groupD8.uX(rotate));\n                v2 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u3 = cX + (w2 * groupD8.uX(rotate));\n                v3 = cY + (h2 * groupD8.uY(rotate));\n            }\n\n            arr[sz++] = x;\n            arr[sz++] = y;\n            arr[sz++] = u0;\n            arr[sz++] = v0;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x + w;\n            arr[sz++] = y;\n            arr[sz++] = u1;\n            arr[sz++] = v1;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x + w;\n            arr[sz++] = y + h;\n            arr[sz++] = u2;\n            arr[sz++] = v2;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n\n            arr[sz++] = x;\n            arr[sz++] = y + h;\n            arr[sz++] = u3;\n            arr[sz++] = v3;\n            arr[sz++] = u + eps;\n            arr[sz++] = v + eps;\n            arr[sz++] = u + w - eps;\n            arr[sz++] = v + h - eps;\n            arr[sz++] = animXEncoded;\n            arr[sz++] = animYEncoded;\n            ints[sz++] = textureId;\n            arr[sz++] = animDivisor;\n            arr[sz++] = alpha;\n        }\n\n        vertexBuf.data = arr;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        if (this.rects_count * POINT_STRUCT_SIZE !== this.pointsBuf.length\n            || (anim && this.hasAnimatedTile))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This will pull forward the modification marker.\n     *\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        this.rects_count = this.pointsBuf.length / POINT_STRUCT_SIZE;\n    }\n\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.tilemapBounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    get bounds()\n    {\n        return this.tilemapBounds;\n    }\n\n    /** @override */\n    destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n        this.destroyVb();\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\n    {\n        this.tile(\n            texture,\n            x,\n            y,\n            {\n                animX,\n                animY,\n            }\n        );\n\n        return true;\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX = 0,\n        animY = 0,\n        rotate = 0,\n        animCountX = 1024,\n        animCountY = 1024,\n        animDivisor = 1,\n        alpha = 1,\n    ): this\n    {\n        return this.tile(\n            textureIndex,\n            x, y,\n            {\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, alpha\n            }\n        );\n    }\n}\n","import { Container, Texture, TextureSource } from 'pixi.js';\nimport { settings } from './settings';\nimport { Tilemap } from './Tilemap';\n\n/**\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\n *\n * The composite tileset is the concatenation of the individual tilesets used in the tilemaps. You can\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\n *\n * @example\n * import { Application } from '@pixi/app';\n * import { CompositeTilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Setup view & stage.\n * const app = new Application();\n *\n * document.body.appendChild(app.renderer.view);\n * app.stage.interactive = true;\n *\n * // Global reference to the tilemap.\n * let globalTilemap: CompositeTilemap;\n *\n * // Load the tileset spritesheet!\n * Loader.shared.load('atlas.json');\n *\n * // Initialize the tilemap scene when the assets load.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      const tilemap = new CompositeTilemap();\n *\n *      // Setup the game level with grass and dungeons!\n *      for (let x = 0; x < 10; x++)\n *      {\n *          for (let y = 0; y < 10; y++)\n *          {\n *              tilemap.tile(\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\n *                  x * 100,\n *                  y * 100,\n *              );\n *          }\n *      }\n *\n *      globalTilemap = app.stage.addChild(tilemap);\n * });\n *\n * // Show a bomb at a random location whenever the user clicks!\n * app.stage.on('click', function onClick()\n * {\n *      if (!globalTilemap) return;\n *\n *      const x = Math.floor(Math.random() * 10);\n *      const y = Math.floor(Math.random() * 10);\n *\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\n * });\n */\nexport class CompositeTilemap extends Container\n{\n    /** The hard limit on the number of tile textures used in each tilemap. */\n    public readonly texturesPerTilemap: number;\n\n    /**\n     * The animation frame vector.\n     *\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\n     * row and `animCountY` per column.\n     *\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\n     */\n    public tileAnim: [number, number] = null;\n\n    /** The last modified tilemap. */\n    protected lastModifiedTilemap: Tilemap = null;\n\n    private modificationMarker = 0;\n    // private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n\n    /**\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\n     *  will work equivalently.\n     */\n    constructor(tileset?: Array<TextureSource>)\n    {\n        super();\n\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\n        this.tileset(tileset);\n    }\n\n    /**\n     * This will preinitialize the tilesets of the layered tilemaps.\n     *\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\n     *\n     * @param tileTextures - The list of tile textures that make up the tileset.\n     */\n    tileset(tileTextures: Array<TextureSource>): this\n    {\n        if (!tileTextures)\n        {\n            tileTextures = [];\n        }\n\n        const texPerChild = this.texturesPerTilemap;\n        const len1 = this.children.length;\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\n\n        for (let i = 0; i < Math.min(len1, len2); i++)\n        {\n            (this.children[i] as Tilemap).setTileset(\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\n            );\n        }\n        for (let i = len1; i < len2; i++)\n        {\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n\n            tilemap.compositeParent = true;\n\n            // TODO: Don't use children\n            this.addChild(tilemap);\n        }\n\n        return this;\n    }\n\n    /** Clears the tilemap composite. */\n    clear(): this\n    {\n        for (let i = 0; i < this.children.length; i++)\n        {\n            (this.children[i] as Tilemap).clear();\n        }\n\n        this.modificationMarker = 0;\n\n        return this;\n    }\n\n    /** Changes the rotation of the last added tile. */\n    tileRotate(rotate: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileRotate(rotate);\n        }\n\n        return this;\n    }\n\n    /** Changes `animX`, `animCountX` of the last added tile. */\n    tileAnimX(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimX(offset, count);\n        }\n\n        return this;\n    }\n\n    /** Changes `animY`, `animCountY` of the last added tile. */\n    tileAnimY(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimY(offset, count);\n        }\n\n        return this;\n    }\n\n    /** Changes `tileAnimDivisor` value of the last added tile. */\n    tileAnimDivisor(divisor: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given tile texture at (x, y).\n     *\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\n     * @param x - The local x-coordinate of the tile's location.\n     * @param y - The local y-coordinate of the tile's location.\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n     *      animation frame textures in the base-texture.\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n     *      animation frames textures in the base-texture.\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n     *      per row.\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n     *      per column.\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\n     * @param [options.alpha=1] - Tile alpha\n     * @return This tilemap, good for chaining.\n     */\n    tile(\n        tileTexture: Texture | string | number,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number,\n            animDivisor?: number,\n            alpha?: number,\n        } = {}\n    ): this\n    {\n        let tilemap: Tilemap = null;\n        const children = this.children;\n\n        this.lastModifiedTilemap = null;\n\n        if (typeof tileTexture === 'number')\n        {\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\n            let tileIndex = 0;\n\n            tilemap = children[childIndex] as Tilemap;\n\n            if (!tilemap)\n            {\n                tilemap = children[0] as Tilemap;\n\n                // Silently fail if the tilemap doesn't exist\n                if (!tilemap) return this;\n\n                tileIndex = 0;\n            }\n            else\n            {\n                tileIndex = tileTexture % this.texturesPerTilemap;\n            }\n\n            tilemap.tile(\n                tileIndex,\n                x,\n                y,\n                options,\n            );\n        }\n        else\n        {\n            if (typeof tileTexture === 'string')\n            {\n                tileTexture = Texture.from(tileTexture);\n            }\n\n            // Probe all tilemaps to find which tileset contains the base-texture.\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i] as Tilemap;\n                const tex = child.getTileset().arr;\n\n                for (let j = 0; j < tex.length; j++)\n                {\n                    if (tex[j] === tileTexture.source)\n                    {\n                        tilemap = child;\n                        break;\n                    }\n                }\n\n                if (tilemap)\n                {\n                    break;\n                }\n            }\n\n            // If no tileset contains the base-texture, attempt to add it.\n            if (!tilemap)\n            {\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\n                for (let i = children.length - 1; i >= 0; i--)\n                {\n                    const child = children[i] as Tilemap;\n\n                    if (child.getTileset().count < this.texturesPerTilemap)\n                    {\n                        tilemap = child;\n                        child.getTileset().push(tileTexture.source);\n                        break;\n                    }\n                }\n\n                // Otherwise, create a new tilemap initialized with that tile texture.\n                if (!tilemap)\n                {\n                    tilemap = new Tilemap(tileTexture.source);\n                    tilemap.compositeParent = true;\n\n                    this.addChild(tilemap);\n                }\n            }\n\n            tilemap.tile(\n                tileTexture,\n                x,\n                y,\n                options,\n            );\n        }\n\n        this.lastModifiedTilemap = tilemap;\n\n        return this;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        const layers = this.children;\n\n        if (this.modificationMarker !== layers.length)\n        {\n            return true;\n        }\n        for (let i = 0; i < layers.length; i++)\n        {\n            if ((layers[i] as Tilemap).isModified(anim))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        const layers = this.children;\n\n        this.modificationMarker = layers.length;\n        for (let i = 0; i < layers.length; i++)\n        {\n            (layers[i] as Tilemap).clearModify();\n        }\n    }\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @see CompositeTilemap.tile\n     */\n    addFrame(\n        texture: Texture | string | number,\n        x: number,\n        y: number,\n        animX?: number,\n        animY?: number,\n        animWidth?: number,\n        animHeight?: number,\n        animDivisor?: number,\n        alpha?: number\n    ): this\n    {\n        return this.tile(\n            texture,\n            x, y,\n            {\n                animX,\n                animY,\n                animCountX: animWidth,\n                animCountY: animHeight,\n                animDivisor,\n                alpha\n            }\n        );\n    }\n\n    /**\n     * @deprecated @pixi/tilemap 3\n     * @see CompositeTilemap.tile\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX?: number,\n        animY?: number,\n        rotate?: number,\n        animWidth?: number,\n        animHeight?: number\n    ): this\n    {\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\n        const textureId: number = textureIndex % this.texturesPerTilemap;\n\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset().count > 0)\n        {\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\n            this.lastModifiedTilemap.addRect(\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\n            );\n        }\n        else\n        {\n            this.lastModifiedTilemap = null;\n        }\n\n        return this;\n    }\n\n    /**\n     * Alias for {@link CompositeTilemap.tileset tileset}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    setBitmaps = this.tileset;\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @readonly\n     * @see CompositeTilemap.texturesPerTilemap\n     */\n    get texPerChild(): number { return this.texturesPerTilemap; }\n}\n","// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\nimport { extensions } from 'pixi.js';\nimport { GlTilemapAdaptor } from './gl_tilemap';\nimport { GpuTilemapAdaptor } from './gpu_tilemap';\nimport { TilemapPipe } from './TilemapPipe';\n\nexport * from './CompositeTilemap';\nexport * from './settings';\nexport * from './Tilemap';\nexport * from './TilemapGeometry';\nexport * from './TilemapPipe';\n\nextensions.add(TilemapPipe);\nextensions.add(GlTilemapAdaptor);\nextensions.add(GpuTilemapAdaptor);\n"],"names":["settings","Constant","i","b","o","a","t","_TilemapGeometry","Geometry","indexBuffer","buf","Buffer","BufferUsage","stride","__publicField","TilemapGeometry","TilemapAdaptor","UniformGroup","Matrix","TilemapPipe","renderer","adaptor","NOOP","geom","size","totalIndices","len","createIndicesForQuads","_renderable","tilemap","instructionSet","batcher","_instructionSet","renderable","pipe_uniforms","u_proj_trans","u_global","anim_frame","u_anim_frame","ExtensionType","outBuffer","j","TileTextureArray","max_textures","tex","ind","tex_sizes","arr","count","null_color","bind_group_resources","bindIndex","texture","Texture","BindGroup","src","sampleValues","samplerSize","gl_tilemap_vertex","gl_tilemap_fragment","GlTilemapAdaptor","pipe","shader","tileset","tu","Shader","GlProgram","gpu_tilemap_vertex","gpu_tilemap_fragment","GpuTilemapAdaptor","GpuProgram","Q","Z","E","A","h","POINT_STRUCT","n","z","POINT_STRUCT_SIZE","Tilemap","ViewContainer","State","Bounds","v","res","bounds","textureOrArray","_a","_b","ts","TextureSource","flag","tileTexture","x","y","options","_c","_d","baseTexture","textureIndex","was_num","textureList","u","tileWidth","tileHeight","animX","animY","rotate","animCountX","animCountY","animDivisor","alpha","pb","offset","divisor","plugin","points","rects_count","vb","vertices","vertexBuf","vs","bk","ints","sz","textureId","w","animWidth","animHeight","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","groupD8","anim","_bounds","M","g","e","CompositeTilemap","Container","tileTextures","texPerChild","len1","len2","children","childIndex","tileIndex","child","layers","extensions"],"mappings":"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"}